import numpy as np
import cv2
import matplotlib.pyplot as plt
from collections import deque
import matplotlib.patches as patches
from math import *
from scipy.ndimage import binary_dilation

# Computing clustered grid based on cluster size
def compute_grid(mask,offset_px,cluster_size):
    h,w = mask.shape

    
    #### NEED TO MOVE THIS TO CUT EDGES OFF ALL PARTS OF IMAGE NOT JUST MASK
    offset_mask = mask[offset_px:h - offset_px, offset_px:w - offset_px]

    h,w = offset_mask.shape ###CHANGE TO MASK AFTER FIXING ABOVE
    # Cluster mask
    clusters_h = h // cluster_size
    clusters_w = w // cluster_size

    inverted = cv2.bitwise_not(offset_mask)
    mask_contour,_ = cv2.findContours(inverted,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
    largest_contour = max(mask_contour,key=cv2.contourArea)
    x,y,w,h = cv2.boundingRect(largest_contour)
    bounded = offset_mask.copy()
    bounded[y:y+h,x:x+w] = 0

    # Create clustered grid from mask
    cluster_grid = np.zeros((clusters_h, clusters_w), dtype=np.uint8)
    for i in range(clusters_h):
        for j in range(clusters_w):
            block = bounded[i*cluster_size:(i + 1)*cluster_size, j*cluster_size:(j + 1)*cluster_size]
            if np.any(block > 0):
                cluster_grid[i,j] = 1
    
    #DEBUGGING
    h,w = cluster_grid.shape
    print('height:',h,'width:',w)

    return cluster_grid

# Finding all points that are reachable for a given cluster
def compute_reachable(start, grid):
    h, w = grid.shape
    reachable = set()
    q = deque([start])
    while q:
        i, j = q.popleft()
        if (i, j) in reachable or grid[i, j] == 0:
            continue
        reachable.add((i, j))
        for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]:
            ni, nj = i+di, j+dj
            if 0 <= ni < h and 0 <= nj < w:
                q.append((ni, nj))
    return reachable

def generate_outward_spiral_from_object(grid):
    """
    Generate an outward spiral starting from the object's boundary and
    expanding into the white area, never crossing the object.
    
    Parameters:
        grid (np.ndarray): Binary mask (1=free, 0=object)
    Returns:
        spiral_coords (list of tuples): (i, j) coordinates of the path
    """
    h, w = grid.shape
    visited = set()
    spiral_coords = []

    # --- Find object boundary ---
    object_mask = (grid == 0)
    dilated = binary_dilation(object_mask)
    boundary = np.logical_and(dilated, ~object_mask)

    # --- Find a starting point (first boundary pixel found) ---
    boundary_points = np.argwhere(boundary)
    if len(boundary_points) == 0:
        raise ValueError("No object boundary found.")
    start_i, start_j = boundary_points[np.lexsort((boundary_points[:,1], boundary_points[:,0]))][0]

    # --- Spiral outward ---
    dirs = [(-1,0), (0,1), (1,0), (0,-1)]  # up, right, down, left
    dir_idx = 1  # start moving right

    current = (start_i, start_j)
    spiral_coords.append(current)

    while True:
        visited.add(current)
        ci, cj = current
        moved = False

        # Try to move forward; if blocked or visited or object, turn right
        for _ in range(4):
            di, dj = dirs[dir_idx]
            ni, nj = ci + di, cj + dj

            if (
                0 <= ni < h and 0 <= nj < w and
                grid[ni, nj] == 1 and
                (ni, nj) not in visited
            ):
                current = (ni, nj)
                spiral_coords.append(current)
                moved = True
                break
            else:
                # Turn right
                dir_idx = (dir_idx + 1) % 4

        if not moved:
            break

    return np.asarray(spiral_coords)

def plan_boustrophedon_path(grid):
    """
    Generate a raster (back-and-forth) path around a single rectangular obstacle.
    Assumes:
        grid[i,j] = 1  -> free cluster
        grid[i,j] = 0  -> obstacle
    Returns:
        path (list of tuples): ordered (row, col) cluster coordinates
    """

    h, w = grid.shape
    path = []

    # Find the obstacle bounds
    ys, xs = np.where(grid == 0)
    #print([(xs,ys) for xs,ys in zip(xs,ys)])
    if len(xs) == 0 or len(ys) == 0:
        # no obstacle: simple raster scan
        for i in range(h):
            row = [(i, j) for j in (range(w) if i % 2 == 0 else range(w-1, -1, -1))]
            path.extend(row)
        return path

    top, bottom = ys.min(), ys.max()
    left, right = xs.min(), xs.max()

    # --- Phase 1: Top section (above obstacle) ---
    for i in range(top):
        if i % 2 == 0:
            for j in range(w):
                path.append((i, j))
        else:
            for j in range(w, -1, -1):
                path.append((i, j))
    
    # --- Phase 2: Around the obstacle ---
    # Move row by row across top of obstacle
    print(abs(path[-1][1] - 0), abs(path[-1][1] - w))
    print(path[-1])
    if abs(path[-1][1] - 0) > abs(path[-1][1] - w): 
        upp = w
        low = right
    else:
        upp = left
        low = 0
    
    for i in range(path[-1][0] + 1, bottom + 1):
        if i % 2 == 0:
            # left → right, skip obstacle interior
            for j in range(low,upp):
                path.append((i, j))
        else:
            # right → left
            for j in range(upp,low, -1):
                print(j)
                path.append((i, j))
    
    # --- Phase 3: Move straight down below obstacle ---
    if path[-1][0] != left and abs(path[-1][0] - left) > abs(path[-1][0] - right):
        path.append((path[-1][0],0))
    elif path[-1][0] != right and abs(path[-1][0] - right) > abs(path[-1][0] - left):
        path.append((path[-1][0],w))

    path.append((h, path[-1][1]))
    
    # Phase 4: Bottom section
    for i in range(h,bottom, -1):
        # resume raster in opposite vertical direction (now sweeping upward)
        row = []
        row_idx = h - (i - bottom)
        # reverse order if continuing serpentine
        if (i - bottom) % 2 == 0:
            for j in (range(w-1, -1, -1)):
                if left <= j <= right:
                    continue
                row.append((i, j))
        else:
            for j in range(w):
                if left <= j <= right:
                    continue
                row.append((i, j))
        path.extend(row)

    if upp == left:
        upp = w
        low = right
    else:
        upp = left
        low = 0
    
    for i in range(bottom + 1,top + 1,-1):
        if i % 2 == 0:
            # left → right, skip obstacle interior
            for j in range(w):
                if low <= j <= upp:
                    path.append((i, j))
        else:
            # right → left
            for j in range(w-1, -1, -1):
                if low <= j <= upp:
                    path.append((i, j))
    
    #print(path)
    return np.asarray(path)

def main():
    # Parameters
    save_path = "path_planning/scripts/testdata"
    npz_file = save_path + "/rgb_xyz_capture_aligned.npz"
    output_file = save_path + "/robot_path.npz"
    cluster_size = 10 # pixels
    offset_px = 10 # pixels

    # Load data
    data = np.load(npz_file)
    mask = data['mask'].astype(np.uint8)  # 0=obstacle, 255=free
    # rgb = data['rgb']  # Uncomment if RGB is valid
    xyz = data['xyz']
    cluster_grid = compute_grid(mask, offset_px, cluster_size)
    
    # Save clustered grid image for debugging purposes
    grid_fig = np.asarray(cluster_grid*255)
    cv2.imwrite(save_path + '/clustered_grid.png',grid_fig)
    #bounded_fig = np.asarray(cropped*255)
    #cv2.imwrite(save_path + '/bounded_grid.png',cropped)
    #path_px = generate_outward_spiral_from_object(cluster_grid)

    path_px = plan_boustrophedon_path(cluster_grid)

    #for idx,(y,x) in enumerate(path_pixels):
        #path_xyz[idx] = xyz[y,x]

    # =====================
    # SAVE PATH
    # =====================
    #np.savez_compressed(output_file, path=path_xyz)
    #print(f"Saved robot path with {len(path_xyz)} points to {output_file}")

    fig,ax = plt.subplots()
    plt.plot(path_px[:,0],path_px[:,1],)
    rect = patches.Rectangle((9,2),18-9,12-2,linewidth=1,edgecolor='black',facecolor='black')
    ax.add_patch(rect)
    plt.savefig(save_path + '/path_overlay.png')

if __name__ == "__main__":
    main()