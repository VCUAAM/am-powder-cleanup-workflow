import numpy as np
import cv2
import matplotlib.pyplot as plt
from collections import deque
from math import *
from scipy.ndimage import binary_dilation

# Computing clustered grid based on cluster size
def compute_grid(mask,offset_px,cluster_size):
    # Apply offset to mask
    kernel_size = offset_px*2 + 1
    mask_offset = cv2.erode(mask, np.ones((kernel_size,kernel_size), np.uint8), iterations=1)

    # Cluster mask
    h, w = mask_offset.shape
    clusters_h = h // cluster_size
    clusters_w = w // cluster_size

    # Create clustered grid from mask
    cluster_grid = np.zeros((clusters_h, clusters_w), dtype=np.uint8)
    for i in range(clusters_h):
        for j in range(clusters_w):
            block = mask_offset[i*cluster_size:(i+1)*cluster_size, j*cluster_size:(j+1)*cluster_size]
            if np.any(block > 0):
                cluster_grid[i,j] = 1

    indices = np.argwhere(cluster_grid == 1)

    # Get the first occurrence
    if indices.size > 0:
        start = tuple(indices[0])
        print(f"First index of 1: {start}")
    else:
        print(f"1 not found in the array.")
    
    return start, cluster_grid

# Finding all points that are reachable for a given cluster
def compute_reachable(start, grid):
    h, w = grid.shape
    reachable = set()
    q = deque([start])
    while q:
        i, j = q.popleft()
        if (i, j) in reachable or grid[i, j] == 0:
            continue
        reachable.add((i, j))
        for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]:
            ni, nj = i+di, j+dj
            if 0 <= ni < h and 0 <= nj < w:
                q.append((ni, nj))
    return reachable

def generate_outward_spiral_from_object(grid):
    """
    Generate an outward spiral starting from the object's boundary and
    expanding into the white area, never crossing the object.
    
    Parameters:
        grid (np.ndarray): Binary mask (1=free, 0=object)
    Returns:
        spiral_coords (list of tuples): (i, j) coordinates of the path
    """
    h, w = grid.shape
    visited = set()
    spiral_coords = []

    # --- Find object boundary ---
    object_mask = (grid == 0)
    dilated = binary_dilation(object_mask)
    boundary = np.logical_and(dilated, ~object_mask)

    # --- Find a starting point (first boundary pixel found) ---
    boundary_points = np.argwhere(boundary)
    if len(boundary_points) == 0:
        raise ValueError("No object boundary found.")
    start_i, start_j = boundary_points[np.lexsort((boundary_points[:,1], boundary_points[:,0]))][0]

    # --- Spiral outward ---
    dirs = [(-1,0), (0,1), (1,0), (0,-1)]  # up, right, down, left
    dir_idx = 1  # start moving right

    current = (start_i, start_j)
    spiral_coords.append(current)

    while True:
        visited.add(current)
        ci, cj = current
        moved = False

        # Try to move forward; if blocked or visited or object, turn right
        for _ in range(4):
            di, dj = dirs[dir_idx]
            ni, nj = ci + di, cj + dj

            if (
                0 <= ni < h and 0 <= nj < w and
                grid[ni, nj] == 1 and
                (ni, nj) not in visited
            ):
                current = (ni, nj)
                spiral_coords.append(current)
                moved = True
                break
            else:
                # Turn right
                dir_idx = (dir_idx + 1) % 4

        if not moved:
            break

    return np.asarray(spiral_coords)

def main():
    # Parameters
    save_path = "path_planning/scripts/testdata"
    npz_file = save_path + "/rgb_xyz_capture_aligned.npz"
    output_file = save_path + "/robot_path.npz"
    cluster_size = 10 # pixels
    offset_px = 5 # pixels

    # Load data
    data = np.load(npz_file)
    mask = data['mask'].astype(np.uint8)  # 0=obstacle, 255=free
    # rgb = data['rgb']  # Uncomment if RGB is valid
    xyz = data['xyz']
    start, cluster_grid = compute_grid(mask, offset_px, cluster_size)
    
    # Save clustered grid image for debugging purposes
    grid_fig = np.asarray(cluster_grid*255)
    cv2.imwrite(save_path + '/clustered_grid.png',grid_fig)
    path_px = generate_outward_spiral_from_object(cluster_grid)
    #reachable = compute_reachable(start,cluster_grid)

    #path_px = compute_path(reachable,cluster_grid,start,cluster_size)

    #path_xyz = np.zeros((len(path_pixels),3), dtype=np.float32)
    #for idx,(y,x) in enumerate(path_pixels):
        #path_xyz[idx] = xyz[y,x]

    # =====================
    # SAVE PATH
    # =====================
    #np.savez_compressed(output_file, path=path_xyz)
    #print(f"Saved robot path with {len(path_xyz)} points to {output_file}")

    fig,ax = plt.subplots()
    plt.plot(path_px[:,0],path_px[:,1],)
    plt.savefig(save_path + '/path_overlay.png')

if __name__ == "__main__":
    main()